+++
title = '메세지 브로커 차이 (RabbitMQ vs Redis)'
date = 2025-02-03T16:52:30+09:00
draft = false
categories = ["posting", "cs"]
descriptions = ""
+++

### RabbitMQ vs Redis를 Celery 브로커로 사용할 때의 가장 큰 차이

RabbitMQ와 Redis는 모두 메시지 브로커로 사용할 수 있지만, 구조, 메시지 처리 방식, 신뢰성, 확장성 측면에서 큰 차이가 있습니다. 이 차이를 이해하면 어떤 브로커가 더 적합한지 상황에 따라 선택할 수 있습니다.

1. 가장 큰 차이: 메시지 브로커로서의 설계 철학

- RabbitMQ (AMQP 기반)
- 메시지 브로커로 설계된 전문 시스템으로, 메시지 큐 관리와 라우팅, 신뢰성 있는 메시지 전달에 특화되어 있습니다.
- **표준 프로토콜인 AMQP(Advanced Message Queuing Protocol)**을 사용하여 **메시지의 확실한 전달(acknowledgement)**과 다양한 라우팅 전략을 지원합니다.
- Redis (빠른 메모리 기반 데이터 저장소)
- 주로 캐싱이나 데이터 저장을 위한 키-값 저장소로 설계되었으며, 단순한 메시지 큐 기능도 지원합니다.
- 메모리 기반의 속도에 최적화되어 있지만, RabbitMQ처럼 복잡한 메시지 라우팅이나 신뢰성 보장 기능은 부족할 수 있습니다.

2. 주요 비교
 | 특징 | RabbitMQ | Redis |
 |:-|:-|:-|
 | 설계 철학 | 전문적인 메시지 브로커 (AMQP 프로토콜) | 메모리 기반의 키-값 저장소 (단순 메시지 큐 지원) |
 | 메시지 전달 보장 | 최대 한 번(at most once), 적어도 한 번(at least once) 등의 다양한 메시지 전달 보장 | 제한적 (일반적으로 적어도 한 번) |
 | 확장성과 메시지 라우팅 | 복잡한 라우팅 지원 (Exchange, Queue, Routing key 등) | 단순 큐 기반, 복잡한 라우팅 불가능 |
 | 속도 | 느릴 수 있지만 신뢰성이 중요할 때 적합 | 메모리 기반으로 매우 빠름 |
 | 메시지 영구 저장 | 디스크 기반으로 메시지 영구 보관 가능 | 기본적으로 메모리 저장 (디스크는 옵션) |
 | 부하 분산| 여러 워커 간 메시지 부하를 균등하게 분산 | 단순히 한 큐에서 읽는 방식 |
 | 신뢰성과 내구성 | 메시지 손실이 적고 안전한 메시지 전달 보장 | 메모리 기반으로 재부팅 시 데이터 손실 가능 |
 | 설정의 복잡성 | 비교적 복잡 (Exchange, Queue, Binding 등) | 설정이 간단하며 바로 사용 가능 |

3. 상황별 선택 기준
 | 사용 상황 | RabbitMQ가 적합 | Redis가 적합 |
 |:-|:-|:-|
 |신뢰성이 중요한 경우|메시지 손실이 허용되지 않거나 메시지 전달 보장이 필요한 경우|메시지 손실이 어느 정도 허용되거나 간단한 큐가 필요한 경우|
 |복잡한 라우팅이 필요한 경우| 다중 큐, 다중 교환기, 라우팅 키 등이 필요한 경우|단순한 FIFO 큐가 필요한 경우|
 |고속 처리/저지연이 필요한 경우|안정성이 더 중요하면 선택 가능하지만 속도는 Redis보다 느림|메모리 기반의 빠른 메시지 처리가 필요할 때|
 |메시지 영구 저장|메시지를 디스크에 영구적으로 보관해야 하는 경우|메모리 기반으로 충분하거나 Redis Persistence가 설정된 경우|
 |설정과 유지보수의 간단함|복잡한 설정과 모니터링이 필요할 때|빠르게 설정하고 바로 사용할 수 있을 때|

4. 예제 시나리오로 이해하기
 **RabbitMQ가 적합한 경우**

- 전자상거래 애플리케이션: 주문 처리가 중단 없이 신뢰성 있게 전달되어야 하고, 각 주문이 정확히 한 번만 처리되는 것이 중요합니다.
- 라우팅이 중요한 대규모 애플리케이션: 서로 다른 서비스로 메시지를 전달할 때 라우팅 키를 사용해 특정 서비스로 메시지를 분배하는 데 적합합니다.

  ```
  Order Service --> RabbitMQ --> Payment Service  
               --> RabbitMQ --> Inventory Service
  ```

 **Redis가 적합한 경우**

- 데이터 처리 파이프라인: 대량의 데이터 처리(예: 로그 데이터, 센서 데이터 등)에서 빠른 큐 처리가 중요하지만 메시지 손실이 큰 문제가 되지 않는 경우.
- 임시 알림 시스템: 사용자 알림이나 채팅 메시지와 같이 지연 없이 빠르게 전달되어야 하는 경우.

  ```
  Log Producer --> Redis Queue --> Log Processor
  ```

5. 성능 비교
 | 항목 | RabbitMQ | Redis |
 |-|-|-|
 | Latency(지연 시간) | 1~10ms 정도로 다소 높음 | 1ms 이하로 매우 빠름 |
 | Throughput(처리량) | 초당 수천 개의 메시지 | 초당 수십만 개의 메시지 처리 가능 |
 | 스케일링 | 수평적 확장 가능하지만 설정 필요 | 단순히 여러 Redis 인스턴스 사용 가능 |

6. 실제 사례

- RabbitMQ 사용 사례
- Slack: 메시지 전달 보장 및 복잡한 라우팅 요구사항이 있는 시스템.
- Etsy: 주문 관리 및 상태 전달에서 정확한 메시지 전달이 중요할 때 사용.

- Redis 사용 사례
- GitHub: 빠른 실시간 알림 및 상태 업데이트.
- Snapchat: 사용자 간 빠른 메시지 전송 및 이벤트 큐 관리.

7. 어떤 브로커를 선택해야 할까?

- RabbitMQ는 메시지 신뢰성과 복잡한 라우팅이 필요할 때 적합합니다.
- 금융 애플리케이션, 전자상거래, 주문 시스템 등
- Redis는 속도와 단순성이 중요한 경우에 적합합니다.
- 실시간 알림, 로그 처리, 임시 데이터 큐 등

8. 결론:

- 안전성 > 속도면 RabbitMQ를, 속도 > 안전성이면 Redis를 선택하기
